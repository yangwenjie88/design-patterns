###单例模式
> 定义: Ensure a class only has one instance, and provide a global point of access to it.
         (确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例)
         
单例模式常用的几种写法

1. 饿汉模式
>   这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，

2. 懒汉模式
>  懒汉模式就是延迟初始化，懒汉正确最好写法是双重检查，实例对象用volatile 关键字修饰。
   貌似很多新手还不是很明白为什么要这样做，这里解释一下：
   volatile 关键字的作用：1. 保证可见性 2. 禁止指令重排序
   假设没有关键字volatile的情况下，两个线程A、B，都是第一次调用该单例方法，线程A先执行instance = new Instance()，该构造方法是一个非原子操作，
   编译后生成多条字节码指令，可以理解分为三步：
   
         1. 分配对象的内存空间ctorInstance(memory); 
         2. 初始化对象instance=memory;
         3. 设置instance指向刚分配的内存地址
>  由于JAVA的指令重排序，2,3可能重排序，先执行3再执行2。该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后instance便不为空了，
   但是实际的初始化操作却还没有执行，如果就在此时线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的Instance对象，
   所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例
   
3. 静态内部类
>  这种方式既保证了线程安全，也能延迟初始化，所以推荐使用静态内部类单例模式

4. 枚举
>  默认枚举实例的创建是线程安全的，并且在任何情况下都是单例

5. 容器模式
>  用Map 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，
   并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度
   
上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。
反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，
就必须加入如下方法：
```
   private Object readResolve() throws ObjectStreamException{
        return singleton;
   }
   
```
